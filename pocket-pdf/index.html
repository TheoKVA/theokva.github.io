<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pocket PDF</title>

    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/jscanify"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>

    <script src="https://docs.opencv.org/4.7.0/opencv.js" async></script>
    <script src="https://cdn.jsdelivr.net/gh/ColonelParrot/jscanify@master/src/jscanify.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        #js-preview {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        #js-preview > * {
            margin: 10px;
            border: 1px solid #ccc;
            padding: 10px;
            max-width: 200px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Pocket PDF</h1>
    <p>Upload or take photos of your documents to assemble them into a PDF.</p>

    <button id="btn-add-image">Add image</button>
    <input id="js-fileInput" type="file" accept="image/*" capture="environment" multiple style="display: none;">

    <div id="js-preview"></div>
    
    <button id="btn-generate">Generate PDF</button>
    <button id="btn-download" disabled>Download PDF</button>

    <!-- CORNER SELECTION -->
    <div id="overlay-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 9999; align-items: center; justify-content: center;">
        <div id="adjustment-container" style="position: relative; width: 90%; max-width: 500px; background-color: white; padding: 20px; border-radius: 10px; text-align: center;">
            <h3>Adjust Corners</h3>
            <div id="image-container" style="position: relative; display: inline-block; width: 100%;">
                <img id="input-image" src="" alt="Loaded Image" style="max-width: 100%; display: block;">
                <div id="top-left-corner" class="corner-marker"></div>
                <div id="top-right-corner" class="corner-marker"></div>
                <div id="bottom-left-corner" class="corner-marker"></div>
                <div id="bottom-right-corner" class="corner-marker"></div>
            </div>
            <button id="confirm-corners">OK</button>
            <button id="cancel-operation">Cancel</button>
        </div>
        <style>
            .corner-marker {
                position: absolute;
                width: 20px;
                height: 20px;
                background-color: red;
                border-radius: 50%;
                cursor: pointer;
                touch-action: none; /* Prevent scrolling during touch */
            }
        </style>
    </div>
    
</body>

<script>

    // HTML
    const fileInputDIV = document.getElementById('js-fileInput');
    const addButton = document.getElementById('btn-add-image');
    const previewDIV = document.getElementById('js-preview');
    const bttnGenerate = document.getElementById('btn-generate');
    const bttnDownload = document.getElementById('btn-download');

    // OVERLAY
    const markersOverlayContainer = document.getElementById('overlay-container');
    const markersInputImage = document.getElementById('input-image');
    const markersDIVelem = {
        topLeftCorner: document.getElementById('top-left-corner'),
        topRightCorner: document.getElementById('top-right-corner'),
        bottomLeftCorner: document.getElementById('bottom-left-corner'),
        bottomRightCorner: document.getElementById('bottom-right-corner'),
    };
    const markersConfirmButton = document.getElementById('confirm-corners');
    const markersCancelButton = document.getElementById('cancel-operation');
    
    // Initiates libraries
    const reader = new FileReader();
    const scanner = new jscanify();
    
    // INPUT
    const paperWidthMM = 210;
    const paperHeightMM = 297;
    const paperDPI = 300 
    const paperWidth = Math.round( paperWidthMM / 25.4 * paperDPI); // in PX
    const paperHeight = Math.round( paperHeightMM / 25.4 * paperDPI); // in PX

    // VARIABLES
    const imagesScanned = [];
    const inputCorners = {
        'top':0,
        'left':0,
        'imageSizeScaled': {},
        'imageSizeOriginal': {},
        'cornerPoints': {} // Store corner points here
    }


    // ----------
    // FILE INPUT
    // ----------
    // Add click event listener to the button
    addButton.addEventListener('click', () => {
        fileInputDIV.click(); // Simulate a click on the file input
    });
    fileInputDIV.addEventListener('change', async (event) => {
        const files = event.target.files;
        
        for (const file of files) {
            console.log('Processing file:', file.name);

            const reader = new FileReader();
            reader.onload = async (e) => {
                console.log('FileReader onload event triggered.');

                let imgSrc = e.target.result;

                // If the file is HEIC, convert it
                if (file.type === 'image/heic' || file.type === 'image/heif') {
                    console.log('HEIC image detected');
                    try {
                        const heicToJpg = await heic2any({ blob: file, toType: 'image/jpeg' });
                        imgSrc = URL.createObjectURL(heicToJpg);
                        console.log('HEIC image converted to JPEG:');
                    } catch (error) {
                        console.error('Error converting HEIC to JPEG:', error);
                    }
                }

                const img = new Image();
                img.src = imgSrc;
                img.onload = () => {
                    console.log('Image loaded for processing:');

                    // Convert image to OpenCV mat
                    const mat = cv.imread(img);
                    // console.log('Converted image to cv.Mat.');

                    // Find the paper contour
                    const contour = scanner.findPaperContour(mat);
                    // console.log('Paper contour detected:', contour);

                    // Get corner points from the contour
                    const cornerPoints = scanner.getCornerPoints(contour);
                    console.log('Corner points detected:', cornerPoints);

                    // Call showMarkersOverlay to fine tune the corners
                    showMarkersOverlay(imgSrc, cornerPoints);
                };
            };

            reader.readAsDataURL(file);
        }
    });


    // ============
    // GENERATE PDF
    // ============

    bttnGenerate.addEventListener('click', async () => {

        console.log('Generate PDF button clicked.');

        const pdfDoc = await PDFLib.PDFDocument.create();
        console.log('PDF document created.');


        // ------------
        // POPULATE PDF
        // ------------

        for (const imageScanned of imagesScanned) {

            // Chope la version processed
            const image = imageScanned.processedImage
            console.log('Embedding image into PDF:', image);
            
            const imgBytes = await fetch(image.toDataURL('image/jpeg')).then((res) => res.arrayBuffer());
            const pdfImage = await pdfDoc.embedJpg(imgBytes);
            console.log('Image embedded as JPEG in PDF:');

            const page = pdfDoc.addPage([pdfImage.width, pdfImage.height]);
            page.drawImage(pdfImage, {
                x: 0,
                y: 0,
                width: pdfImage.width,
                height: pdfImage.height,
            });
            console.log('Image drawn on PDF page.');
        }

        // --------------
        // --------------

        const pdfBytes = await pdfDoc.save(); // Save as raw bytes
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        bttnDownload.disabled = false; // Enable the button

        // iOS-specific handling
        if (isIOS()) {
            // Enable the Share button for supported devices
            if (navigator.share) {
                const file = new File([blob], "document.pdf", { type: 'application/pdf' });
                bttnDownload.addEventListener("click", async () => {
                    try {
                        // Use the Share API
                        await navigator.share({
                            title: "My PDF Document",
                            text: "Here is the PDF document I generated.",
                            files: [file], // Share the PDF file
                        });
                        console.log("PDF shared successfully!");
                    } catch (error) {
                        console.error("Error sharing PDF:", error);
                    }
                });
            } 
            else {
                const downloadLinkIOS = document.createElement('a');
                downloadLinkIOS.href = URL.createObjectURL(blob);
                downloadLinkIOS.download = 'document.pdf';
                downloadLinkIOS.style = 'display: none'; // Invisible link

                // Append and prepare for manual trigger
                document.body.appendChild(downloadLinkIOS);
                bttnDownload.addEventListener("click", function () {
                    downloadLinkIOS.click(); // Trigger the download
                });
            }
        } else {
            // Handling for other platforms
            const blobUrl = URL.createObjectURL(blob);

            // Update download button
            bttnDownload.href = blobUrl;
            bttnDownload.download = 'document.pdf';

            // Try to open in a new tab (optional fallback)
            const pdfWindow = window.open(blobUrl);
            if (!pdfWindow) {
                console.warn('Popup blocked. Download link enabled instead.');
            }
        }
    });



    // ================
    // MARKER SELECTION
    // ================

    // Function to position markers based on corner points
    function positionMarkers() {
        console.log(inputCorners);

        let a = inputCorners;
        let b = inputCorners.imageSizeScaled;
        let c = inputCorners.imageSizeOriginal;
        let d = inputCorners.cornerPoints;

        markersDIVelem.topLeftCorner.style.left = `${- 10 + (b.width * d.topLeftCorner.x / c.width)}px`;
        markersDIVelem.topLeftCorner.style.top = `${- 10 + (b.height * d.topLeftCorner.y / c.height)}px`;

        markersDIVelem.topRightCorner.style.left = `${- 10 + (b.width * d.topRightCorner.x / c.width)}px`;
        markersDIVelem.topRightCorner.style.top = `${- 10 + (b.height * d.topRightCorner.y / c.height)}px`;

        markersDIVelem.bottomLeftCorner.style.left = `${- 10 + (b.width * d.bottomLeftCorner.x / c.width)}px`;
        markersDIVelem.bottomLeftCorner.style.top = `${- 10 + (b.height * d.bottomLeftCorner.y / c.height)}px`;

        markersDIVelem.bottomRightCorner.style.left = `${- 10 + (b.width * d.bottomRightCorner.x / c.width)}px`;
        markersDIVelem.bottomRightCorner.style.top = `${- 10 + (b.height * d.bottomRightCorner.y / c.height)}px`;
    }

    // Function to make markers draggable
    function makeMarkersDraggable(marker, cornerKey) {
        const moveAt = (x, y) => {
            let a = inputCorners;
            let b = inputCorners.imageSizeScaled;
            let c = inputCorners.imageSizeOriginal;
            // Update the UI
            marker.style.left = `${x - 10 - a.left}px`;
            marker.style.top = `${y - 10 - a.top}px`;
            a.cornerPoints[cornerKey] = {
                x: c.width * (x - a.left) / b.width, 
                y: c.height * (y - a.top) / b.height
            };
        };

        const onMouseMove = (e) => moveAt(e.clientX, e.clientY);
        const onTouchMove = (e) => {
            const touch = e.touches[0];
            moveAt(touch.clientX, touch.clientY);
        };

        // Mouse events
        marker.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', onMouseMove);
                console.log(inputCorners.cornerPoints);
            }, { once: true });
        });

        // Touch events
        marker.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            moveAt(touch.clientX, touch.clientY); // Set initial position
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', () => {
                document.removeEventListener('touchmove', onTouchMove);
                console.log(inputCorners.cornerPoints);
            }, { once: true });
        });
    }
    Object.entries(markersDIVelem).forEach(([key, marker]) => {
        makeMarkersDraggable(marker, key);
    });

    // Confirm button logic
    markersConfirmButton.addEventListener('click', () => {
        console.log('Adjusted Corner Points:', inputCorners.cornerPoints);
        markersOverlayContainer.style.display = 'none';

        // Extract the paper using the confirmed corner points
        const processedCanvas = scanner.extractPaper(markersInputImage, paperWidth, paperHeight, inputCorners.cornerPoints);
        console.log('Processed canvas generated with adjusted corners.');

        imagesScanned.push({
            'sourceImage': markersInputImage,
            'cornerPoints': inputCorners.cornerPoints,
            'processedImage': processedCanvas,
        });

        previewDIV.appendChild(processedCanvas);
        console.log('Processed image preview added to the page.');
    });

    // Cancel button logic
    markersCancelButton.addEventListener('click', () => {
        console.log('Operation cancelled by the user.');
        markersOverlayContainer.style.display = 'none';
    });

    // Function to show the overlay for corner adjustment
    function showMarkersOverlay(imgSrc, detectedCorners) {
        markersInputImage.src = imgSrc;
        markersInputImage.onload = () => {
            // Show the image
            markersOverlayContainer.style.display = 'flex';

            // Update the input variable
            const rect = markersInputImage.getBoundingClientRect();
            console.log(rect);
            inputCorners.top = rect.top;
            inputCorners.left = rect.left;
            inputCorners.imageSizeScaled.width = rect.width;
            inputCorners.imageSizeScaled.height = rect.height;
            inputCorners.imageSizeOriginal.width = markersInputImage.naturalWidth;
            inputCorners.imageSizeOriginal.height = markersInputImage.naturalHeight;
            inputCorners.cornerPoints = detectedCorners;

            // Position the markers
            positionMarkers();
        };
    }



    // ======
    // HELPER
    // ======
    const ios = () => {
        if (typeof window === `undefined` || typeof navigator === `undefined`) return false;
        return /iPhone|iPad|iPod/i.test(navigator.userAgent || navigator.vendor || (window.opera && opera.toString() === `[object Opera]`));
    };

    // Check for iOS platform
    function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

</script>

</html>

